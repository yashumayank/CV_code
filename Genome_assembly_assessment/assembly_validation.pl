#!/usr/bin/perl -w

=head1 SYNOPSIS

assembly_validation.pl - Comprehensive statistical analysis of the quality of Assembly by re-mapping the reads to the resulting contigs or scaffolds. Coverage, heterogeneity, number of spanning good-pairs and average insert length are calculated for each library at each base.

=head1 USAGE

assembly_validation1.pl -r|--reference <fasta_assembly> -v|--vcf-file <vcf_file> [-a|--accept-too-long-pairs <string>] lib1.sam lib2.sam ...

=head1 INPUT

=head2 -r|--reference <fasta_assembly>

Whole assembly in fasta format. Works best with one fasta entry per scaffold.

=head2 -v|--vcf <vcf_file>

A VCF file created by piling up all mapped libraries (paied and single ended) using samtools mpileup command and bcftools view command. Can be generated by using:

    samtools mpileup -uf assembly.fasta lib1.bam lib2.bam lib3.bam > valdiation.bcf
    bcftools view validation.bcf > validation.vcf

=head2 -a|--accept-wrong-size-pairs <string>

Whether the pairs receiving a wrong-size flag (i.e. having both ends mapped properly in the correct orientation but without the SAM flag 2) are accepted. 0 (FALSE) by default, or 1. The argument can be specified for each library passing a string of 0s and 1s separated by commas. For example, for libraries lib1 lib2 and lib3, if one wants to accept wrong-size pairs for lib2 but not for the other two, one will pass the argument -a 0,1,0.

=head2 -m|--minimum

=head2 lib1.sam lib2.sam ...

Sorted SAM files library lib1 mapped to the assembly using bwa. For example, for a short paired-end library

    bwa index -p assembly assembly.fasta
    bwa aln assembly lib1_1.fastq > lib1_1.sai
    bwa aln assembly lib1_2.fastq > lib1_2.sai
    bwa sampe -s assembly lib1_1.sai lib1_2.sai lib1_1.fastq lib1_2.fastq | samtools view -Sb - | samtools sort - lib1.bam
    samtools index lib1.bam
    samtools view lib1.bam > lib1.sam

=head1 OUTPUT

A tab-separated file, with one line per base in the assembly. The columns give overall assembly quality statistics per base (scaffold, position, reference base, coverage, divergence), and statistics per library (overlapping good pairs, average insert size). Output to STDOUT.

=head1 AUTHOR

Mayank Mahajan (yashumayank@hotmail.com)
Lionel Guy (lionel.guy@icm.uu.se)

=head1 DATE

Fri Apr 22 13:19:31 CEST 2012

=cut

# Modules

$|++;
use strict;
use Getopt::Long;
use Bio::SeqIO;
use File::Basename;

######### Arguments & options ##################################################
my $assembly_fasta;
my $pileup_file;
#my $acceptwrong = 0;
my @acceptwrongs;

&GetOptions('r|reference=s' => \$assembly_fasta,
            'v|vcf=s'       => \$pileup_file,
#            'a|accept-wrong-size-pairs=s' => \$acceptwrong,
        );
usage() unless (@ARGV && $assembly_fasta && $pileup_file);

# Count libraries, check accept_wrong argument;
my $nlibs = scalar(@ARGV);
#@acceptwrongs = split(/,/, $acceptwrong);
#if (scalar (@acceptwrongs) == 1){
#    @acceptwrongs = ($acceptwrong) x $nlibs;
#}
#elsif (scalar (@acceptwrongs) != $nlibs){
#    warn "Length of accept-wrong-size-pairs argument should be of same " . 
#              "length as the number of libraries";
#    usage();
#}



######### Read Fasta ###########################################################
print STDERR "Reading fasta file...\n";
my $ass  = Bio::SeqIO->new(-file => "$assembly_fasta" , '-format' => 'fasta');
#my $skip=0;
my %ref = ();
my %coverage = ();
my %divergence = ();
my %goodReads = ();
my %avgLength = ();

my %tlen = ();
my %reads = ();
my %checkreads = ();
my $avgNumer = 0;
my $avgDenomin = 0;
my $scafSam = "";
my $scafpos = 0;
my $readlength = 0;

# create indexes
while (my $seq = $ass->next_seq) {
    # $skip++;
    # if($skip>2){
    #   last;
    # }

    my $scafid = $seq->id;
    my $strfasta = $seq->seq;
    my $len = $seq->length()-1;
    for my $position (0 .. $len){
        # print "$scafid,$position\n";
        $ref{"$scafid"}[$position] = substr($strfasta,$position,1);
        $coverage{"$scafid"}[$position] = 0;
        $divergence{"$scafid"}[$position] = 0;
        foreach my $i (0 .. $#ARGV) {
	        $goodReads{"$scafid"}[$position][$i] = 0;
	        $avgLength{"$scafid"}[$position][$i] = 0;
        }
    }
}
print STDERR "  Read ", scalar(keys(%ref)), " fasta sequences from ", 
    $assembly_fasta, "\n";

######### Read Pileup ##########################################################
print STDERR "Reading pileup file...\n";
open pileupFile, "<$pileup_file" or die $!; 
my @flags = ();
my $nlines;

# parsing the pileup file #:::::::::::::::: Start
while (<pileupFile>) {
    $nlines++;
    print STDERR "  Read $nlines lines\r" unless ($nlines % 10000);
    chomp;
    #if (substr($lines,0,1) eq '#'){
    if (/^#/) {
        next;
    }
    my @tokens = split(/\t/, $_);
    my $scaf= $tokens[0];
    my $position= $tokens[1]-1;
    # if(!exists $ref{$index}){
    #   $ref{$index}=$tokens[3];
    # }
    $tokens[7] =~ m/DP=([\d]{1,4});/;
    if ($1==0){
        next;
    }
    $coverage{$scaf}[$position]=$1;
    $tokens[7] =~ m/I16=[\d]{1,4},[\d]{1,4},([\d]{1,4}),([\d]{1,4}),/;
    if(exists $divergence{$scaf}[$position]){
        $divergence{$scaf}[$position]=$divergence{$scaf}[$position]+
            (($1+$2)/$coverage{$scaf}[$position]);
    }
    else {
        $divergence{$scaf}[$position]=($1+$2)/$coverage{$scaf}[$position];
    }
    # print "$coverage[$tokens[1]]  $1 $2 $divergence[$tokens[1]]\n";
}
close(pileupFile);
print STDERR "  Read $nlines in pileup file $pileup_file\n";
# parsing the pileup file #::::::::::::::: Stop

######### Read sams ############################################################
print STDERR "Reading SAM file...\n";
my @libnames;
foreach my $i (0 .. $#ARGV){
    my $libname = basename($ARGV[$i], qw/.sorted.sam .sam/);
    push @libnames, $libname;
    processSAM($ARGV[$i], $i, $acceptwrongs[$i]);
}
# if ($opt_s ne "wicked2"){
#       processSAM($opt_s,0);
# }
# if ($opt_l ne "head2"){
#       processSAM($opt_l,1);
# }

# Print all stats
print STDERR "Printing results\n";
print2File();
print STDERR "Done\n\n";

#########################
# Subs
########################
# SAM file processing. Takes three arguments, the file name, library index and
# the acceptwrong argument
sub processSAM {
    # Initialize variables
    my ($fileName, $i, $acceptwrong) = @_;
    #print STDERR "  fileName: $fileName; RT: $RT \n" ;
    # accepted forward and reverse flags
    my %fwds = ('99' => 1, '163' => 1);
    my %revs = ('83' => 1, '147' => 1);
    ## If we accept wrong size pairs, add it to the accpted flags
    #if ($acceptwrong){
    #    $fwds{'97'}++; $fwds{'161'}++;
    #    $revs{'81'}++; $revs{'145'}++;
    #}
    # my $f1=0;
    # my $f2=0;
    # my $f3=0;
    # my $f4=0;
    # Tries with accepting all
    # my $maxLength1=99999;
    # my $minLength1=0;
    # my $maxLength2=0;
    # my $minLength2=0;
    # if ($RT==1){
    #   $f1=81;
    #   $f2=145;
    #   $f3=161;
    #   $f4=97;
    #   $maxLength1=8000;
    #   $minLength1=0;
    #   $maxLength2= -100;
    #   $minLength2=0;
    # }
    # else {
    #   $f1=163;
    #   $f2=99;
    #   $f3=147;
    #   $f4=83;
    #   $maxLength1=600;
    #   $minLength1=0;
    #   $maxLength2 = -100;
    #   $minLength2=0;
    # }

    # open file
    open sFile, "<$fileName" or die $!;
    %tlen = ();
    %reads = ();
    %checkreads = ();
    #$skip=0;
    $avgNumer = 0;
    $avgDenomin= 0;
    $scafSam = "";  # current scaffold
    $scafpos=0;
    my $readlength =0;
    my $nlines;

    # read through file
    while (<sFile>) {
        $nlines++;
        print STDERR "  Read $nlines lines\r" unless ($nlines % 10000);
        chomp;
        #my $lines = $_;
        # Read title (to be coded)
        #if (substr($lines,0,1) eq '@'){
        if (/^@/) {
            next;
        }
        # sdata contains fields of each SAM file line
        my @sdata = split;
        # New scaffold? => do stats
        if ($sdata[2] ne $scafSam){
            # $skip++;
            # if($skip>2){
            #   last;
            # }
            # process the remaining bases from old scaf
            while ($scafpos <= $#{ $goodReads{$scafSam}}){
                $goodReads{$scafSam}[$scafpos][$i] = $avgDenomin;
                if ($avgDenomin==0){
                    $avgLength{$scafSam}[$scafpos][$i] = 0;
                }
                else{
                    $avgLength{$scafSam}[$scafpos][$i] = $avgNumer/$avgDenomin;
                }
                $scafpos++;

                # delete expired templates
                delXpiredReads();
            }
            ##print old scaf statistics
            #print STDERR "    ", join("\n    ", keys %reads), "\n";
            my $keycount = scalar keys(%reads);
            print STDERR "    $scafSam: $keycount unclosed reads in $scafSam : ";
            print STDERR "    Final values avgN:$avgNumer; avgD: $avgDenomin\n";
            print STDERR "----Printing only the reads which do not span outside the scaffold.\n";
            foreach my $it (keys(%reads)){
                #my $tlen = $tlen{$i};
                #$tlen = "no tlen" unless $tlen;
				if($reads{$it}<$scafpos){
					print STDERR "    $it\t$reads{$it}\t$tlen{$it}\n";
				}
            }
            # reinitialize variables
            %tlen = ();
            %reads = ();
            $avgNumer = 0;
            $avgDenomin= 0;
            %checkreads=();
            $scafSam = $sdata[2];
            $scafpos=0;
        }
        # until ref index = sam index update gap bases -------------------------
        while ($scafpos+1 < $sdata[3]){
            $goodReads{$scafSam}[$scafpos][$i] = $avgDenomin;
            if ($avgDenomin==0){
                $avgLength{$scafSam}[$scafpos][$i] = 0;
            } else{
                $avgLength{$scafSam}[$scafpos][$i] = $avgNumer/$avgDenomin;
            }
            $scafpos++;

            # delete expired templates
            delXpiredReads();
        }
        #if ($i==1){
       # $readlength= length($sdata[9]);
            #}
        # process new read from SAM
        if (exists $checkreads{$sdata[0]}){
            delete $checkreads{$sdata[0]};
            $reads{$sdata[0]}+= $readlength;
        }
        else {
            # Forward read, irrespective of which strand
            # Try without checking max size
            if (($fwds{$sdata[1]})&&($sdata[6] eq "=")){
                # && ($sdata[8]>$minLength1)&&($sdata[8]<$maxLength1)){
                $reads{$sdata[0]}= $sdata[3]+$sdata[8]+$readlength;
                $tlen{$sdata[0]}= $sdata[8];
                $checkreads{$sdata[0]}= $sdata[8];
                $avgNumer+=$sdata[8];
                $avgDenomin+=1;
            }
            # Reverse read
            elsif (($revs{$sdata[1]})&&($sdata[6] eq "=")){
                # &&($sdata[8]<$minLength2)&&($sdata[8]>$maxLength2)){
                $reads{$sdata[0]}= $sdata[3]-$sdata[8];
                $tlen{$sdata[0]}= -$sdata[8];
                $checkreads{$sdata[0]}= $sdata[8];
                $avgNumer+=-$sdata[8];
                $avgDenomin+=1;
            }
        }
    }
    close(sFile);
    print STDERR "  Read $nlines lines from SAM file $fileName\n";
}
# parsing the sam files #================ Stop

sub delXpiredReads {
    foreach my $i (keys(%tlen)){
        if($scafpos>=$reads{$i}){
        	if(!exists $tlen{$i})	
				{print STDERR "$i\n";}
#            print STDERR "$i\n" unless (exists $tlen{$i});
            $avgNumer-=$tlen{$i};
            $avgDenomin--;
            delete $reads{$i};
            delete $tlen{$i};
        }
    }
}


## Print results to STDOUT
sub print2File{
    # Print title
    print "scaff\tpos\tref\tcoverage\tdivergence";
    # Loop over libraries
    foreach my $libname (@libnames){
        print "\t$libname\_goodPairs\t$libname\_averageInsert";
    }
    print "\n";
    # Loop over scaffolds
    foreach my $i (keys(%ref)){
        # Loop over positions
        for my $p (0 .. $#{ $ref{$i} } ) {
            my $pp=$p+1;
            print "$i\t$pp\t$ref{$i}[$p]\t$coverage{$i}[$p]\t" . 
                fstr($divergence{$i}[$p]);
            # Loop over libraries
            foreach my $j (0 .. $#libnames){
                print "\t".fstr($goodReads{$i}[$p][$j])."\t".fstr($avgLength{$i}[$p][$j]);
            }
            print "\n";
        }
    }
}
sub parseFlag{
    my $FlagCode = shift;
    # lstFlags = [["read paired", 0x1],
    #           ["read mapped in proper pair", 0x2],
    #           ["read unmapped", 0x4],
    #           ["mate unmapped", 0x8],
    #           ["read reverse strand", 0x10],
    #           ["mate reverse strand", 0x20],
    #           ["first in pair", 0x40],
    #           ["second in pair", 0x80],
    #           ["not primary alignment", 0x100],
    #           ["read fails platform/vendor quality checks", 0x200],
    #           ["read is PCR or optical duplicate", 0x400]];
    # for my $f (1024,512,256,128,64,32,16,8,4,2,1){ 

    if(($FlagCode & 0x1)&&
           ($FlagCode & 0x2)&&
               (($FlagCode & 0x10)xor
                    ($FlagCode & 0x20))){
        if(($FlagCode & 0x4)||
               ($FlagCode & 0x8)||
                   ($FlagCode & 0x200)||
                       ($FlagCode & 0x400)){
            return 0;
        }
        else {
            return 1;
        }
    }
    else{
        return 0;
    }
}

sub fstr {
  my ($value,$precision) = @_;
  $precision ||= 3;
  my $s = sprintf("%.${precision}f", $value);
  $s =~ s/\.?0*$//;
  $s
}

sub usage{
    system("perldoc $0");
    exit;
}
